"""Tool-gap detection and proposal service.

Extracted from ``evolution/skills.py`` (SelfImprovementEngine).  Owns
recurring tool-failure detection, negative preference signal logging,
diagnostic tool code generation, and the owner-gated proposal flow.
"""
from __future__ import annotations

import json
import logging
import textwrap
from datetime import datetime, timedelta, timezone
from pathlib import Path
from typing import Any

from utils import atomic_write

import config
import db_pool
from evolution.infra import (
    _TOOL_GAP_MIN_FAILURES,
    _TOOL_GAP_WINDOW_DAYS,
)

log = logging.getLogger(__name__)



class ToolGapsService:
    """Tool-gap detection and proposal service.

    Receives explicit ``InfraService``, ``OwnerCommsService``, and
    ``SkillGapsService`` dependencies.
    """

    def __init__(self, ctx, infra, comms, skill_gaps):
        from evolution.context import EngineContext
        from evolution.infra import InfraService
        from evolution.owner_comms import OwnerCommsService
        from evolution.skill_gaps import SkillGapsService as _SkillGapsService
        self.ctx: EngineContext = ctx
        self.infra: InfraService = infra
        self.comms: OwnerCommsService = comms
        self.skill_gaps: _SkillGapsService = skill_gaps

    def detect_tool_gap_candidates(
        self,
        days: int = _TOOL_GAP_WINDOW_DAYS,
        min_failures: int = _TOOL_GAP_MIN_FAILURES,
    ) -> list[dict[str, Any]]:
        cutoff = (datetime.now(timezone.utc) - timedelta(days=days)).isoformat()
        rows = self.infra.rows(
            config.MOLLYGRAPH_PATH,
            """
            SELECT tool_name,
                   COUNT(*) AS failures,
                   MAX(created_at) AS last_failed_at,
                   MAX(CASE WHEN trim(coalesce(error_message, '')) <> '' THEN error_message ELSE '' END) AS sample_error
            FROM tool_calls
            WHERE created_at > ?
              AND success = 0
              AND tool_name NOT LIKE 'approval:%'
              AND tool_name NOT LIKE 'routing:%'
            GROUP BY tool_name
            ORDER BY failures DESC, last_failed_at DESC
            """,
            (cutoff,),
        )

        candidates: list[dict[str, Any]] = []
        for row in rows:
            failures = int(row.get("failures", 0) or 0)
            if failures < min_failures:
                continue
            tool_name = str(row.get("tool_name", "")).strip()
            if not tool_name:
                continue
            sample_error = str(row.get("sample_error", "") or "").strip()
            candidates.append(
                {
                    "tool_name": tool_name,
                    "failures": failures,
                    "last_failed_at": str(row.get("last_failed_at", "")),
                    "sample_error": sample_error,
                }
            )
        return candidates

    def log_negative_preference_signal(
        self,
        source: str,
        surfaced_summary: str,
        sender_pattern: str,
        owner_feedback: str,
    ):
        try:
            from memory.retriever import get_vectorstore

            vs = get_vectorstore()
            vs.log_preference_signal(
                source=source,
                surfaced_summary=surfaced_summary,
                sender_pattern=sender_pattern,
                owner_feedback=owner_feedback,
                signal_type="self_improve_rejection",
            )
        except Exception:
            log.debug("Failed to log negative preference signal", exc_info=True)

    def build_failure_diagnostic_tool(
        self,
        source_tool_name: str,
        failures: int,
        sample_error: str = "",
    ) -> tuple[str, str, str]:
        source_slug = self.infra.slug(source_tool_name) or "tool"
        source_ident = source_slug.replace("-", "_")
        tool_name = f"Diagnose {source_slug} failures"
        function_name = f"diagnose_{source_ident}_failures"
        db_path = str(config.MOLLYGRAPH_PATH)
        safe_source_tool_name = source_tool_name.replace("\\", "\\\\").replace("'", "\\'")
        safe_db_path = db_path.replace("\\", "\\\\").replace("'", "\\'")
        safe_error = sample_error.replace("\\", "\\\\").replace("'", "\\'")

        tool_code = textwrap.dedent(
            f"""\
            \"\"\"Operational diagnostics helper generated by self-improvement.

            Read-only helper for inspecting recent failed calls for a specific tool.
            \"\"\"

            import sqlite3
            from datetime import datetime, timezone
            from pathlib import Path

            import db_pool

            TARGET_TOOL = '{safe_source_tool_name}'
            DB_PATH = Path('{safe_db_path}')


            def {function_name}(limit: int = 20) -> dict:
                capped = max(1, min(int(limit), 200))
                if not DB_PATH.exists():
                    return {{
                        "tool_name": TARGET_TOOL,
                        "count": 0,
                        "failures": [],
                        "error": f"mollygraph_missing:{{DB_PATH}}",
                    }}

                conn = db_pool.sqlite_connect(str(DB_PATH))
                conn.row_factory = sqlite3.Row
                try:
                    rows = conn.execute(
                        \"\"\"
                        SELECT created_at, error_message, parameters
                        FROM tool_calls
                        WHERE tool_name = ?
                          AND success = 0
                        ORDER BY created_at DESC
                        LIMIT ?
                        \"\"\",
                        (TARGET_TOOL, capped),
                    ).fetchall()
                finally:
                    conn.close()

                failures = [
                    {{
                        "created_at": str(row["created_at"] or ""),
                        "error_message": str(row["error_message"] or ""),
                        "parameters": str(row["parameters"] or ""),
                    }}
                    for row in rows
                ]
                return {{
                    "tool_name": TARGET_TOOL,
                    "count": len(failures),
                    "generated_at": datetime.now(timezone.utc).isoformat(),
                    "failures": failures,
                }}
            """
        ).strip() + "\n"

        test_code = textwrap.dedent(
            f"""\
            import importlib.util
            from pathlib import Path


            def _resolve_tool_path() -> Path:
                tools_dir = Path(__file__).resolve().parent.parent / "tools"
                for candidate in sorted(tools_dir.glob("*.py")):
                    try:
                        text = candidate.read_text(encoding="utf-8")
                    except Exception:
                        continue
                    if "def {function_name}" in text:
                        return candidate
                raise FileNotFoundError("Generated tool file not found")


            def _load_module():
                tool_path = _resolve_tool_path()
                spec = importlib.util.spec_from_file_location("candidate_tool", str(tool_path))
                module = importlib.util.module_from_spec(spec)
                assert spec is not None and spec.loader is not None
                spec.loader.exec_module(module)
                return module


            def test_{function_name}_returns_structured_payload():
                module = _load_module()
                fn = getattr(module, "{function_name}")
                payload = fn(limit=5)
                assert isinstance(payload, dict)
                assert payload.get("tool_name") == "{safe_source_tool_name}"
                assert "failures" in payload
                assert isinstance(payload["failures"], list)
            """
        ).strip() + "\n"

        if safe_error:
            test_code += f"\n# Observed sample error while generating this candidate: '{safe_error}'\n"
        if failures > 0:
            test_code += f"# Observed failures in the last window: {failures}\n"
        return tool_name, tool_code, test_code

    async def propose_tool(
        self,
        tool_name: str,
        tool_code: str,
        test_code: str,
        read_only: bool = True,
        requires_auth: bool = False,
    ) -> dict[str, Any]:
        """Draft tool in sandbox, test in subprocess, propose install."""
        self.infra.ensure_sandbox_dirs()
        tool_slug = self.infra.slug(tool_name) or "tool"
        tool_file = self.ctx.tools_dir / f"{tool_slug}.py"
        test_file = self.ctx.tests_dir / f"test_{tool_slug}.py"
        atomic_write(tool_file, tool_code.rstrip() + "\n")
        atomic_write(test_file, test_code.rstrip() + "\n")

        tests_ok, tests_log = self.infra.run_pytest_target(test_file, f"tool-{tool_slug}")
        tier = "AUTO" if read_only and not requires_auth else "CONFIRM"
        proposal = (
            f"ðŸ”§ New tool proposal: \"{tool_name}\"\n\n"
            f"Tier recommendation: {tier}\n"
            f"Read-only: {read_only}\n"
            f"Requires auth: {requires_auth}\n"
            f"Tests: {'PASS' if tests_ok else 'FAIL'}\n"
            f"Test log: {tests_log}\n\n"
            "Reply YES to install, NO to skip, or EDIT: [changes]."
        )
        await self.comms.notify_owner(proposal)
        self.comms.log_improvement_event(
            event_type="proposal",
            category="tool",
            title=tool_name,
            payload=json.dumps(
                {"tool_file": str(tool_file), "test_file": str(test_file), "tier": tier, "tests_ok": tests_ok},
                ensure_ascii=True,
            ),
            status="proposed",
        )
        decision = await self.comms.request_owner_decision(
            category="self-improve-tool",
            description=proposal,
            required_keyword="YES",
            allow_edit=True,
        )
        if decision is True:
            live_path = self.ctx.project_root / "tools" / f"{tool_slug}.py"
            atomic_write(live_path, tool_file.read_text())
            self.comms.log_improvement_event(
                event_type="proposal",
                category="tool",
                title=tool_name,
                payload=f"installed={live_path};tier={tier}",
                status="approved",
            )
            return {"status": "approved", "path": str(live_path), "tier": tier}
        if isinstance(decision, str):
            return {"status": "edit_requested", "edit": decision}
        self.comms.log_improvement_event(
            event_type="proposal",
            category="tool",
            title=tool_name,
            payload="",
            status="rejected",
        )
        self.log_negative_preference_signal(
            source="self-improve-tool",
            surfaced_summary=f"Tool proposal rejected: {tool_name}",
            sender_pattern=tool_name,
            owner_feedback="owner_rejected_tool_proposal",
        )
        return {"status": "rejected"}

    async def propose_tool_updates_from_failures(
        self,
        days: int = _TOOL_GAP_WINDOW_DAYS,
        min_failures: int = _TOOL_GAP_MIN_FAILURES,
    ) -> dict[str, Any]:
        candidates = self.detect_tool_gap_candidates(days=days, min_failures=min_failures)
        if not candidates:
            return {"status": "skipped", "reason": "no recurring tool failures"}

        for candidate in candidates:
            source_tool_name = str(candidate.get("tool_name", "")).strip()
            if not source_tool_name:
                continue
            source_slug = self.infra.slug(source_tool_name) or "tool"
            proposal_title = f"Diagnose {source_slug} failures"
            if self.skill_gaps.has_recent_event(category="tool", title=proposal_title, days=30):
                continue
            existing_live = self.ctx.project_root / "tools" / f"diagnose-{source_slug}-failures.py"
            if existing_live.exists():
                continue

            gate_msg = (
                "ðŸ§© Tool-gap candidate detected\n\n"
                f"Source tool: {source_tool_name}\n"
                f"Failures ({days}d): {int(candidate.get('failures', 0) or 0)}\n"
                f"Last failure: {str(candidate.get('last_failed_at', '')) or '-'}\n"
                f"Sample error: {str(candidate.get('sample_error', ''))[:240] or '(none)'}\n\n"
                "Reply YES to draft a sandbox tool proposal, NO to skip."
            )
            gate_decision = await self.comms.request_owner_decision(
                category="self-improve-tool-gap",
                description=gate_msg,
                required_keyword="YES",
                allow_edit=False,
            )
            gate_status = "approved" if gate_decision is True else "rejected"
            self.comms.log_improvement_event(
                event_type="proposal",
                category="tool-gap",
                title=proposal_title,
                payload=json.dumps(
                    {
                        "source_tool_name": source_tool_name,
                        "failures": int(candidate.get("failures", 0) or 0),
                        "days": int(days),
                        "sample_error": str(candidate.get("sample_error", ""))[:500],
                    },
                    ensure_ascii=True,
                ),
                status=gate_status,
            )
            if gate_decision is not True:
                self.log_negative_preference_signal(
                    source="self-improve-tool-gap",
                    surfaced_summary=proposal_title,
                    sender_pattern=source_tool_name,
                    owner_feedback="owner_rejected_tool_gap_candidate",
                )
                continue

            tool_name, tool_code, test_code = self.build_failure_diagnostic_tool(
                source_tool_name=source_tool_name,
                failures=int(candidate.get("failures", 0) or 0),
                sample_error=str(candidate.get("sample_error", "") or ""),
            )
            return await self.propose_tool(
                tool_name=tool_name,
                tool_code=tool_code,
                test_code=test_code,
                read_only=True,
                requires_auth=False,
            )

        return {"status": "skipped", "reason": "no new tool candidates"}
